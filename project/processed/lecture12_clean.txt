Binary Trees – Overview A binary tree is an ordered tree where each node
has at most two children. These children are called the left child and
the right child.

Possible Representations A binary tree can be represented in several
ways.

One representation uses an array. The first array position contains the
root. The left child of index i is at position 2 * i. The right child is
at position 2 * i + 1. Empty positions use a special placeholder.

Another representation uses linked structures. Each node stores
information and pointers to its left and right children. The root
pointer is NIL when the tree is empty.

A third representation stores child indices in arrays. A linked list of
empty positions is maintained to simplify node allocation.

Binary Tree Traversal Tree traversal refers to visiting all nodes in a
tree. There are four main traversal types. These types are preorder,
inorder, postorder, and level-order traversal.

Tree Representation Model A tree node stores its element and pointers to
its left and right children. The tree structure stores only a pointer to
the root.

Preorder Traversal Preorder traversal visits the root first. It then
traverses the left subtree and finally the right subtree. A
non-recursive version uses a stack and pushes the right child before the
left child.

Inorder Traversal In inorder traversal, the algorithm explores the left
subtree first. It then visits the root and afterward explores the right
subtree. An inorder traversal of a binary search tree produces sorted
output.

Postorder Traversal Postorder traversal processes the left subtree
first. It then processes the right subtree and finally visits the root.
Non-recursive versions use either one or two stacks.

Level-Order Traversal Level-order traversal visits nodes by levels from
top to bottom. It uses a queue to manage the order of visits.

Binary Tree Iterators Iterators visit tree elements one at a time. They
support initialization, retrieving the current element, advancing to the
next element, and checking whether the iterator is valid.

Remembering Traversal Orders Preorder visits the root first. Inorder
visits the root between the left and right subtrees. Postorder visits
the root last.

Reconstructing a Tree from Traversal Orders A tree can be reconstructed
when preorder and inorder traversals are known. It can also be
reconstructed when postorder and inorder traversals are known. Preorder
and postorder alone do not uniquely identify a tree.

Binary Search Trees A binary search tree is a binary tree with ordering
rules. Values in the left subtree are less than or equal to the node’s
value. Values in the right subtree are greater. An inorder traversal of
a binary search tree produces sorted values.

Binary Search Tree Representation A binary search tree node stores the
element and pointers to its children. The tree itself stores only a
pointer to the root.

Searching in a Binary Search Tree A search begins at the root. If the
element equals the node’s value, the search succeeds. If it is greater,
the algorithm continues in the right subtree. If it is smaller, it
continues in the left subtree. Search operations may be recursive or
non-recursive. The time complexity depends on tree height.

Inserting into a Binary Search Tree The insert operation places a new
value according to the ordering rule. If the target location is empty, a
new node is created. If the value is less than or equal to the current
node, insertion continues in the left subtree. Otherwise, it continues
in the right subtree. The insertion time depends on the height of the
tree.

Finding Minimum or Maximum To find the minimum, the algorithm repeatedly
follows left child pointers. To find the maximum, it repeatedly follows
right child pointers.

Finding the Parent of a Node If parent pointers are not stored, the
parent can be found by searching from the root. The algorithm tracks the
last node that leads to the target.

Finding the Successor The successor of a node is the next value in
sorted order. If the node has a right subtree, the successor is the
minimum value of that subtree. If not, the successor is the lowest
ancestor encountered by moving upward along left-child edges. Without
parent pointers, the algorithm performs one traversal from the root and
tracks the last ancestor with a greater value.

Removing a Node Node removal depends on the number of children. If the
node has no children, it is removed directly. If the node has one child,
it is replaced by that child. If the node has two children, the node’s
value is replaced by either the maximum value in the left subtree or the
minimum value in the right subtree. After replacement, the chosen node
is removed separately.

Maintaining Positional Information A binary search tree can support
position-based operations when each node stores the number of nodes in
its left subtree. This count helps determine whether to traverse left or
right during such operations.

Binary Search Trees with Duplicate Values Duplicate values follow the
“less than or equal to” rule and may appear in left subtrees. Counting
duplicates can be done by traversing the tree and counting all matching
nodes. Removal follows the same cases used for any value.

Summary This lecture presented binary trees, traversal algorithms,
binary search trees, and common operations such as search, insertion,
deletion, and successor calculation.
